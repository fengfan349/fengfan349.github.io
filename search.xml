<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GPIO驱动学习实践]]></title>
    <url>%2F2017%2F06%2F02%2Fgpio_driver%2F</url>
    <content type="text"><![CDATA[简介linux驱动有三大类：字符设备驱动、块设备驱动、网络设备驱动。&lt;br&gt; 本文关注的是字符设备驱动-----以LED驱动为例 程序设计头文件下面是一些必要的头文件：1234567891011121314151617181920212223#include &lt;linux/module.h&gt;#include &lt;linux/moduleparam.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/kernel.h&gt; /* printk() */#include &lt;linux/slab.h&gt; /* kmalloc() */#include &lt;linux/fs.h&gt; /* everything... */#include &lt;linux/errno.h&gt; /* error codes */#include &lt;linux/types.h&gt; /* size_t */#include &lt;linux/proc_fs.h&gt;#include &lt;linux/fcntl.h&gt; /* O_ACCMODE */#include &lt;linux/aio.h&gt;#include &lt;linux/ioport.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/ioctl.h&gt; /* needed for the _IOW etc stuff used later */#include &lt;linux/mm.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;asm/uaccess.h&gt; /*put_user*/#include &lt;asm/io.h&gt;#include &lt;asm/system.h&gt; /* cli(), *_flags */#include &lt;asm/page.h&gt;#include &lt;asm/semaphore.h&gt; 宏定义IMMAP内部存储器映射寄存器这一部分是IO空间对应的唯一的物理空间地址：12#define IMMAP_BASE 0xFF000000 //物理地址#define IMMAP_LEN 0x100000 //地址空间大小 用户程序在运行中不能直接访问物理地址,这个地址是唯一的，我们需要将物理地址映射到0~4G大小的虚拟地址空间供用户程序使用；而驱动程序可以分为用户模式驱动和内核模式驱动： 地址空间划分 linux内核将虚拟地址空间划分为两部分供用户使用 用户空间：0x00000000~0xBFFFFFFF的3G大小的低地址空间； 内核空间：0xC0000000~0xFFFFFFFF的1G大小的高地址空间。 设备驱动模式 用户驱动模式： 实现函数： 1immr_map (&amp;immr, IMMAP_LEN, IMMAP_BASE); //将物理地址空间映射到低3G地址的用户空间，将映射后的地址保存在immr内部存储器映射寄存器中 上述函数实现物理地址映射是通过系统调用mmap函数实现的，过程如下： 12fd = open (MEM_FILE, O_RDWR)) //打开内存文件 /dev/mem*start = (VUINT32) mmap (NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FILE, fd, base)) //返回映射到用户进程虚拟地址空间的基地址 注：mmap负责把文件内容映射到进程的虚拟地址空间，通过对这段内存的读取和修改来实现对文件的读取和修改，而不需要再调用read和write； 内核驱动模式 主、次设备号12#define IO_MAJOR 250 #define IO_MINOR 0 在Linux内核看来，主设备号标识设备对应的驱动程序，告诉Linux内核使用哪一个驱动程序为该设备(也就是/dev下的设备文件)服务；而次设备号则用来标识具体且唯一的某个设备]]></content>
      <categories>
        <category>嵌入式linux驱动</category>
      </categories>
      <tags>
        <tag>GPIO</tag>
        <tag>字符设备驱动</tag>
        <tag>LED</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoAhead WebServer学习]]></title>
    <url>%2F2017%2F05%2F27%2F2017-05-27%2F</url>
    <content type="text"><![CDATA[Goahead简介GoAhead WebServer 它是一个源码免费、功能强大、可以在多个平台运行的嵌入式WebServer。 支持ASP 嵌入式的javascript 标准的CGI执行 内存中的CGI处理GoForms 扩展的API 快速响应，每秒可处理超过50个请求 完全和标准兼容 如果不包含SSI，仅要求60K的内存；包含SSI，要求500K内存 web页面可以存在ROM或文件系统中 支持多种操作系统，包括eCos 、LINUX 、LynxOS 、QNX 、VxWorks 、WinCE Goahead核心ASP过程用来获得嵌入式系统正在运行中的进程的各种状态信息，并最终返回响应浏览 在goahead服务器中，网页以.asp的扩展名保存，asp是一种动态服务页面； 要创建一个ASP文件中的ASP脚本就必须使用asp界定符 &lt;% function(arguments, …); %&gt;，这里的脚本使用goahead所支持的嵌入式javascript即Ejscript； Ejscript由goahead提供支持，goahead提供Ejscript解析器负责解析脚本函数，定位、传递脚本函数中的实参给此脚本函数对应的c语言实现的经过注册的全局函数; 在goahead源码中使用一个自己定义的c函数，这个c函数通过调用goahead服务器中API函数 websAspDefine 向服务器注册此c函数，这样此c函数便成为了Ejscript的一个全局函数，负责具体实现Ejscript查询显示信息的功能。具体实例 1234567891011static int aspTest(int eid, webs_t wp, int argc, char_t **argv)&#123; char_t *name, *address; if (ejArgs(argc, argv, T("%s %s"), &amp;name, &amp;address) &lt; 2) &#123; websError(wp, 400, T("Insufficient args\n")); return -1; &#125; return websWrite(wp, T("Name: %s, Address %s"), name, address);&#125;websAspDefine(T("aspTest"), aspTest); GoForm过程根据Form表单Post上来的表单信息去设置和管理嵌入式系统设备 GoAhead WebServer可以实现一个灵活的URL处理程序； .asp网页文件中form表单样式’ action=”/goform/ConfigInfo” action=”post” ‘,goahead服务器url处理器会自动解析goform/之后的内容； 解析后的内容 ConfigInfo 对应于goahead服务器中经过 websFormDefine 注册的C程序，这里与ASP过程中的注册过程类似，这里的C程序负责处理表单数据并与系统主进程通信； 上述的过程便是goahead提供的Goform过程，即内存中的CGI处理过程，与标准的CGI处理过程的区别是这里的Goform过程与goahead服务器进程共享地址空间，Goform过程所需得到的表单信息均由goahead服务器提供的标准的API函数 websGetVar 来获得，标准版本的CGI处理会导致在对于每一个CGIURL的请求产生一个新的进程；具体实例 12345678910111213static void formTest(webs_t wp, char_t *path, char_t *query)&#123; char_t *name, *address; name = websGetVar(wp, T("name"), T("Joe Smith")); address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); websHeader(wp); websWrite(wp, T("&lt;body&gt;&lt;h2&gt;Name: %s, Address: %s&lt;/h2&gt;\n"), name, address); websFooter(wp); websDone(wp, 200);&#125;websFormDefine(T("formTest"), formTest); Goahead架构 GoAhead源码分析—转载 webs-2-5/ | 各种OS移植子目录，分别有：CE、ECOS、LINUX、LYNX、MACOSX、NW、QNX4、VXWORKS、WIN | utils：当前只有webcomp.c，即网页编译器 | www：存放web网页 | wwwdemo：goAhead带的demo网页，里面包含了goAhead的一些文档 | goAhead: 服务器源程序文件(C程序文件) Goahead移植本文中的移植过程是转载自下面这篇文献的，虽然目标平台不同，但方法基本一样,致谢原作者！Goahead 嵌入式web服务器移植到arm9 2440 + linux中 开发环境 宿主机 戴尔windows 10操作系统； 虚拟机 Redhat Enterprise Linux5； 开发板 主控芯片为PowerPC架构的MPC85xx系列的实验板； 内核版本linux-2.6.20 交叉编译器 ppc_8xx-gcc; 源码下载 Goahead-2.5 下载链接 移植步骤修改Makefile文件选择LINUX目录下的Makefile文件，添加如下内容:12345678AS = $(CROSS_COMPILE)as LD = $(CROSS_COMPILE)ld CC = $(CROSS_COMPILE)gcc AR = $(CROSS_COMPILE)ar NM = $(CROSS_COMPILE)nm STRIP = $(CROSS_COMPILE)strip OBJCOPY = $(CROSS_COMPILE)objcopy OBJDUMP = $(CROSS_COMPILE)objdump 这里的CROSS_COMPILE是虚拟机交叉编译环境经变量 ppc_8xx-gcc&lt;br&gt; 同时需要根据情况注释掉Makefile中的下列语句： 1matrixsslDir:=$(shell ls -d ../matrixssl-3-1*/) 这一句是用来启动SSL matrixssl的,若当前系统不支持，就按上面所说注释掉这一句；Goahead官方文档中给出的说明如下： The Makefiles for LINUX and MACOSX will detect the MatrixSSL package, apply the necessary preprocessor defines, and link with the SSL library. 修改main.c文件由于LINUX/main.c文件：initWebs()函数中原程序无法正确获得服务器IP；因此置服务器一个静态IP地址。12345678910111213141516171819/* * Define the local Ip address, host name, default home page and the * root web directory. */ /* del by gyr 2011.09.17 if (gethostname(host, sizeof(host)) &lt; 0) &#123; error(E_L, E_LOG, T("Can't get hostname")); printf("initWebs::Can't get hostname.\n"); return -1; &#125; if ((hp = gethostbyname(host)) == NULL) &#123; error(E_L, E_LOG, T("Can't get host address")); printf("initWebs::Can't get hostname...\n"); return -1; &#125; memcpy((char *) &amp;intaddr, (char *) hp-&gt;h_addr_list[0], (size_t) hp-&gt;h_length); */ intaddr.s_addr = inet_addr(T("192.168.186.138")); 此处的ip地址可以是我们指定好的实验板的ip地址，也可以是在这里编写程序使得goahead服务器到flash中读取得到的地址； 修改default.c文件在上文中提到的本次移植过程的参考文章中碰到了打不开网页的现象，我在实践过程中也遇到了相同的情况；错误提示：123Access Error: Site or Page Not FoundCannot open URL 参考文章给出了解决方法，这里就不详细描述了，解决方法请参考上文链接；这个错误与默认网页的处理有关，具体涉及到了default.c文件中的WebsDefaultHandler()函数。 编译源码修改完必要的文件之后便可以执行编译过程了 1make clean; make 编译成功之后会生成一个可执行的文件./webs和一个./libwebs.a的静态库文件，由于我这里实验板使用的文件系统为网络文件系统NFS，所以这里可以复制这两个文件所在目录与网页文件所在目录到目标版的文件系统当中，执行程序1./webs 或者1./webs -demo 之后打开浏览器，访问http://192.168.186.138:8080 便可以访问到默认网页内容。 后续接下来的过程中我将使用Goahead作为web服务器完成路由器网络管理部分应用层的设计，主要是面向管理人员和用户的网页管理配置部分的内容。]]></content>
      <categories>
        <category>web服务器</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到我的博客 文章以嵌入式系统相关内容为主，其中有错误的地方欢迎及时指正，共勉！]]></content>
  </entry>
</search>