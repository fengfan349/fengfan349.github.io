<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[随笔]]></title>
      <url>/2017/12/25/Informal_essay/</url>
      <content type="html"><![CDATA[<p>不知道写什么，就随便写点规划吧！</p>
<p>1.</p>
]]></content>
      
        <categories>
            
            <category> Informal essay </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[GUI学习之Eclipse RCP]]></title>
      <url>/2017/09/13/eclipse_rcp_1/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> GUI开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GUI </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[3S大赛]]></title>
      <url>/2017/09/06/3s_1/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3>]]></content>
      
        <categories>
            
            <category> Smart Service System </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RaspberryPi </tag>
            
            <tag> python </tag>
            
            <tag> yeelink </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GUI学习之Duilib]]></title>
      <url>/2017/08/18/duilib_1/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        Duilib 是一款强大的界面开发工具，可以将用户界面和处理逻辑彻底分离，极大地提高用户界面的开发效率。其使用C++开发，利用xml构建应用程序界面。duilib库提供了完成应用程序界面设计的基本组件，包括各种控件与布局方式，使用xml语言设计用户界面，duilib库提供了对xml文件的解析，用来根据xml文件的描述来创建出用户所希望看到的桌面应用程序。目前已经有很多桌面应用程序采用了duilib库，较为著名的有微信PC端应用程序以及百度杀毒等。</p>
<p>​    这里再多说两句，其实本来自己对于编程语言来讲只本科阶段系统学过C语言，html制作网页，即使是这样也不敢说对C语言能够掌握，对于其他的编程语言只是听过名字比如大名鼎鼎的C++，java，还有python，在学习的过程中也慢慢开始接触这几种都使用了面向对象思想的语言。C++与Java都是因为要用到制作windows桌面的应用程序而接触到的，就比如现在开始写得这个duilib库开发的过程就直接使用了C++，后面还会学习使用了一种利用java开发应用程序的方法，eclipse RCP框架，至于python这个后面还会继续详谈。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>​       目前duilib库源文件在github上，但已经基本没有什么人去定期维护升级库的功能，网络上也有很多程序员自己维护的duilib库也很不错，我自己也有想法维护自己的一套duilib库，去开发一些方便自己使用的控件，目前我已经尝试为duilib库中原有的控件增加百分比控制布局大小的功能，相关代码也放在了自己的github上，这仅仅是个开始。虽然自己现在还是一个菜鸟，更不要说对于C++编程了，但是有志者事竟成嘛，希望有一天自己也能有一套有自己特色的完美的duilib库！</p>
<p>​      我在使用的时候是下载的是官方github上的duilib库，这个库除了duilib的源码之外还提供了丰富的demo供初学者参考，这些demo中几乎涵盖了我在初学过程中遇到的所有问题。</p>
<p>从github上clone到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone: https://github.com/duilib/duilib.git</div></pre></td></tr></table></figure>
<p>使用需要注意的是这个版本工程使用VS2013，其他版本的VS去编译的话很可能出问题，需要做适当的转换，具体方法网上有相应的教程，我这里用的VS2008版本的。</p>
]]></content>
      
        <categories>
            
            <category> GUI开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GUI </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SNMP学习实践]]></title>
      <url>/2017/06/28/snmp_1/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> SNMP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SNMP </tag>
            
            <tag> MIB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GPIO驱动学习实践]]></title>
      <url>/2017/06/02/gpio_driver/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><pre><code>linux驱动有三大类：字符设备驱动、块设备驱动、网络设备驱动
本文关注的是字符设备驱动-----以LED驱动为例
</code></pre><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>下面是一些必要的头文件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/moduleparam.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;		/* printk() */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;		/* kmalloc() */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;			/* everything... */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;		/* error codes */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;		/* size_t */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/proc_fs.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fcntl.h&gt;		/* O_ACCMODE */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/aio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioctl.h&gt; 		/* needed for the _IOW etc stuff used later */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mm.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;	/*put_user*/</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/system.h&gt;		/* cli(), *_flags */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/page.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/semaphore.h&gt;</span></span></div></pre></td></tr></table></figure></p>
<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><h4 id="IMMAP内部存储器映射寄存器"><a href="#IMMAP内部存储器映射寄存器" class="headerlink" title="IMMAP内部存储器映射寄存器"></a>IMMAP内部存储器映射寄存器</h4><p>这一部分是IO空间对应的唯一的物理空间地址：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IMMAP_BASE	0xFF000000 <span class="comment">//物理地址</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IMMAP_LEN	0x100000  <span class="comment">//地址空间大小</span></span></div><div class="line"><span class="comment">/* 此处一般有一个自定义设备结构体，用来保存设备相关的各种信息，包括主、次设备号，物理地址映射寄存器等必要结构，如下所示 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_dev_s</span></span></div><div class="line">&#123;</div><div class="line">	u16 major;</div><div class="line">	u16 minor;</div><div class="line">	gpio_pa pa;</div><div class="line">	gpio_pb pb;</div><div class="line">	gpio_pd pd;</div><div class="line">	gpio_pc pc;</div><div class="line">	u32 phy_immr;</div><div class="line">	u32 phy_base;</div><div class="line">	u32 phy_len;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">cs</span>;</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">class_device</span> *<span class="title">cd</span>;</span>		</div><div class="line">	<span class="keyword">spinlock_t</span> lock;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></div><div class="line">&#125;io_dev;</div></pre></td></tr></table></figure></p>
<p>用户程序在运行中不能直接访问物理地址,这个地址是唯一的，我们需要将物理地址映射到0~4G大小的虚拟地址空间供用户程序使用；而驱动程序可以分为用户模式驱动和内核模式驱动：<br></p>
<ul>
<li>地址空间划分<br><br>  linux内核将虚拟地址空间划分为两部分供用户使用<br><ul>
<li>用户空间：0x00000000~0xBFFFFFFF的3G大小的低地址空间；</li>
<li>内核空间：0xC0000000~0xFFFFFFFF的1G大小的高地址空间。</li>
</ul>
</li>
<li><p>设备驱动模式</p>
<ul>
<li><p>用户驱动模式：<br><br>  实现函数：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">immr_map (&amp;immr, IMMAP_LEN, IMMAP_BASE); <span class="comment">//将物理地址空间映射到低3G地址的用户空间，将映射后的地址保存在immr内部存储器映射寄存器中</span></div></pre></td></tr></table></figure>
<p>  上述函数实现物理地址映射是通过系统调用mmap函数实现的，过程如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fd = open (MEM_FILE, O_RDWR)) <span class="comment">//打开内存文件 /dev/mem</span></div><div class="line">*start = (VUINT32) mmap (<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FILE, fd, base)) <span class="comment">//返回映射到用户进程虚拟地址空间的基地址</span></div></pre></td></tr></table></figure>
<p>  注：mmap负责把文件内容映射到进程的虚拟地址空间，通过对这段内存的读取和修改来实现对文件的读取和修改，而不需要再调用read和write；这里的操作是把系统内存看作一个文件，而GPIO相关的寄存器是这个文件中的一部分内容，通过映射,GPIO的实际物理地址映射为用户空间的虚拟地址，这样返回一个虚拟空间GPIO的起始地址，便可以根据地址偏移量计算每个寄存器的虚拟地址，进而达到在用户空间程序直接访问的目的。</p>
</li>
<li><p>内核驱动模式：<br><br>  实现函数：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">request_mem_region(io_dev.phy_base, io_dev.phy_len, IO_DRIVER_NAME); <span class="comment">//为该驱动向内核申请指定物理地址的使用权，一旦获得使用权其他驱动便不可以使用这段内存；</span></div><div class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>) ioremap(io_dev.phy_base, io_dev.phy_len)； <span class="comment">//得到该段物理地址空间的权限之后还需要将该段物理地址映射到内核地址空间，供内核调用；</span></div></pre></td></tr></table></figure>
<p>  这里内核驱动模式与用户驱动模式的区别在于用户模式下驱动的控制是直接读写IO的映射之后的虚拟地址实现的，而本部分的内核调用是先使用系统调用函数诸如read，write等等进入内核空间，再由内核使用内核调用函数（由用户编写的read，write，ioctl等函数，下面会提到）来实现对IO的控制；本次对于GPIO驱动的控制是使用的内核驱动模式。</p>
</li>
</ul>
</li>
</ul>
<h4 id="主、次设备号"><a href="#主、次设备号" class="headerlink" title="主、次设备号"></a>主、次设备号</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_MAJOR	211    </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> IO_MINOR	0</span></div></pre></td></tr></table></figure>
<p>在Linux内核看来，主设备号标识设备对应的驱动程序，告诉Linux内核使用哪一个驱动程序为该设备(也就是/dev下的设备文件)服务；而次设备号则用来标识具体且唯一的某个设备。</p>
<h3 id="驱动实现-io-init-amp-io-exit"><a href="#驱动实现-io-init-amp-io-exit" class="headerlink" title="驱动实现 io_init &amp; io_exit"></a>驱动实现 io_init &amp; io_exit</h3><ol>
<li>实现物理地址到内核空间的映射并计算各个寄存器的地址偏移量；</li>
<li><p>获取dev_t类型的设备编号并以此向内核注册该设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dev = MKDEV(io_dev.major,io_dev.minor);</div><div class="line">register_chrdev_region(dev, <span class="number">1</span>, IO_DRIVER_NAME);</div></pre></td></tr></table></figure>
</li>
<li><p>编写各个内核调用的函数诸如：io_open, io_close, io_read, io_write,io_ioctl,同时初始化file_operations结构体，实例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*这里以io_ioctl为例*/</span></div><div class="line"><span class="keyword">ssize_t</span> io_ioctl(struct inode * inode, struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</div><div class="line">&#123;</div><div class="line">	io_dev * dev; <span class="comment">//自定义设备结构体</span></div><div class="line">	dev = filp-&gt;private_data;</div><div class="line">	<span class="keyword">switch</span>(cmd)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">case</span> LED_CTRL_INIT:</div><div class="line">			*(dev-&gt;pb.pbpar) &amp;= ~(arg);</div><div class="line">			*(dev-&gt;pb.pbdir) |= arg;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> LED_CTRL_ON:</div><div class="line">			*(dev-&gt;pb.pbdat) &amp;= ~(arg);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> LED_CTRL_OFF:</div><div class="line">			*(dev-&gt;pb.pbdat) |= arg;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">			<span class="keyword">break</span>;	</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">io_fops</span> = &#123;</span></div><div class="line">	.owner 	=	THIS_MODULE,</div><div class="line">	.read 	=	io_read,</div><div class="line">	.write 	=	io_write,</div><div class="line">	.open 	=	io_open,</div><div class="line">	.ioctl  =   io_ioctl,</div><div class="line">	.release =	io_release,	</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>初始化cdev结构体，cdev结构体是设备驱动实现的关键，cdev是linux用来管理字符设备的结构体，其在内核中采用数组结构设计，这样系统中有多少个主设备号就约定了数组大小，此设备号采用链表管理，同一主设备号下可以有多个子设备。设备即文件，上层应用要访问设备，必须通过文件，cdev中包含file_operations结构体，该结构体就是驱动的文件操作集合。其分为一下几个步骤：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cdev_init(&amp;dev-&gt;cdev, &amp;io_fops);</div><div class="line">dev-&gt;cdev.owner 	= THIS_MODULE;</div><div class="line">dev-&gt;cdev.ops 		= &amp;io_fops;</div><div class="line"></div><div class="line">cdev_add (&amp;dev-&gt;cdev, devno, <span class="number">1</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>创建设备类，使得当调用insmod命令加载驱动时可以自动在/dev目录下创建该设备节点文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">io_dev.cs = class_create(THIS_MODULE,IO_DRIVER_NAME);</div><div class="line">io_dev.cd = class_device_create(io_dev.cs, <span class="literal">NULL</span>, dev, <span class="literal">NULL</span>, IO_DRIVER_NAME);</div></pre></td></tr></table></figure>
</li>
<li><p>卸载设备-io_exit<br> 前面部分实现的是设备加载时调用执行的程序即io_init(),而设备退出时也需要响应的函数即io_exit:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cdev_del(&amp;io_dev.cdev);</div><div class="line">unregister_chrdev_region(MKDEV (io_dev.major, io_dev.minor), <span class="number">1</span>);</div><div class="line">iounmap((<span class="keyword">void</span> __iomem *)io_dev.phy_immr);</div><div class="line">release_mem_region(io_dev.phy_base,io_dev.phy_len);</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>至此设备驱动基本编写完毕，但仍有一些后续工作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module_init(io_init); <span class="comment">/* load the module */</span></div><div class="line">module_exit(io_exit); <span class="comment">/* unload the module */</span></div><div class="line"></div><div class="line"><span class="comment">/* before is some decription of the model,not necessary */</span></div><div class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</div><div class="line">MODULE_AUTHOR(<span class="string">"zhangh"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="编译驱动"><a href="#编译驱动" class="headerlink" title="编译驱动"></a>编译驱动</h2><pre><code>这里需要将源文件编译为.ko的驱动模块，使用insmod加载到内核，相应的rmmod命令删除驱动模块。
下面是一个标准的Makefile：
</code></pre><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KERNELRELEASE)</span>,)           <span class="comment">#开始满足这个条件 KERNELRELEASE为空 </span></div><div class="line">KERNELDIR ?= /home/zhanghao/task/kernal/linux-2.6.20    <span class="comment">#指定Linux内核目录位置  </span></div><div class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span>    <span class="comment">#打印当前驱动源码的本地位置  </span></div><div class="line"><span class="section">modules:               #编译为驱动模块  </span></div><div class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules  </div><div class="line"><span class="comment">#-C 指定内核Makefile的路径，可以使用相对路径。  </span></div><div class="line"><span class="comment">#-M 指定要编译的文件的路径，可以使用相对路径。  </span></div><div class="line"><span class="section">modules:</span></div><div class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span>  modules </div><div class="line"><span class="section">clean:  </span></div><div class="line">	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions modules.order Module.symvers  </div><div class="line">  </div><div class="line"><span class="keyword">else</span>   <span class="comment">#再次读取这个Makefile文件时 KERNELRELEASE已被赋值</span></div><div class="line">MODULE_NAME := my_gpio    <span class="comment">#指定驱动模块的名字 ,不要和当前目录下的文件同名(算上扩展名比较) </span></div><div class="line">CORE_OBJS := my_gpio.o    <span class="comment">#指定驱动模块的核心文件（有init 和 exit）  </span></div><div class="line">DEPE_OBJS := *.o  <span class="comment">#除了核心文件以外的其它依赖文件  </span></div><div class="line"><span class="variable">$(MODULE_NAME)</span>-objs := <span class="variable">$(DEPE_OBJS)</span> <span class="variable">$(CORE_OBJS)</span>   <span class="comment">#指定驱动模块的所有依赖文件  </span></div><div class="line">obj-m := my_gpio.o   <span class="comment">#最终由xxx-objs链接生成my_gpio.o，再生成my_gpio.ko  </span></div><div class="line"><span class="keyword">endif</span></div></pre></td></tr></table></figure>
<p><a href="http://blog.csdn.net/shanzhizi/article/details/8626526" target="_blank" rel="external">Makefile参考链接</a></p>
]]></content>
      
        <categories>
            
            <category> 嵌入式linux驱动 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GPIO </tag>
            
            <tag> 字符设备驱动 </tag>
            
            <tag> LED </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GoAhead WebServer学习]]></title>
      <url>/2017/05/27/2017-05-27/</url>
      <content type="html"><![CDATA[<h2 id="Goahead简介"><a href="#Goahead简介" class="headerlink" title="Goahead简介"></a>Goahead简介</h2><p><a href="http://embedthis.com/goahead/" target="_blank" rel="external">GoAhead WebServer</a> 它是一个源码免费、功能强大、可以在多个平台运行的嵌入式WebServer。</p>
<ol>
<li>支持ASP</li>
<li>嵌入式的javascript</li>
<li>标准的CGI执行</li>
<li>内存中的CGI处理GoForms</li>
<li>扩展的API</li>
<li>快速响应，每秒可处理超过50个请求</li>
<li>完全和标准兼容</li>
<li>如果不包含SSI，仅要求60K的内存；包含SSI，要求500K内存</li>
<li>web页面可以存在ROM或文件系统中</li>
<li>支持多种操作系统，包括eCos 、LINUX 、LynxOS 、QNX 、VxWorks 、WinCE</li>
</ol>
<h2 id="Goahead核心"><a href="#Goahead核心" class="headerlink" title="Goahead核心"></a>Goahead核心</h2><h3 id="ASP过程"><a href="#ASP过程" class="headerlink" title="ASP过程"></a>ASP过程</h3><h4 id="用来获得嵌入式系统正在运行中的进程的各种状态信息，并最终返回响应浏览"><a href="#用来获得嵌入式系统正在运行中的进程的各种状态信息，并最终返回响应浏览" class="headerlink" title="用来获得嵌入式系统正在运行中的进程的各种状态信息，并最终返回响应浏览"></a>用来获得嵌入式系统正在运行中的进程的各种状态信息，并最终返回响应浏览</h4><ul>
<li>在goahead服务器中，网页以.asp的扩展名保存，asp是一种动态服务页面；</li>
<li>要创建一个ASP文件中的ASP脚本就必须使用asp界定符  &lt;% function(arguments, …); %&gt;，这里的脚本使用goahead所支持的嵌入式javascript即Ejscript；</li>
<li>Ejscript由goahead提供支持，goahead提供Ejscript解析器负责解析脚本函数，定位、传递脚本函数中的实参给此脚本函数对应的c语言实现的经过注册的全局函数;</li>
<li>在goahead源码中使用一个自己定义的c函数，这个c函数通过调用goahead服务器中API函数 websAspDefine 向服务器注册此c函数，这样此c函数便成为了Ejscript的一个全局函数，负责具体实现Ejscript查询显示信息的功能。<h4 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h4></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aspTest</span><span class="params">(<span class="keyword">int</span> eid, <span class="keyword">webs_t</span> wp, <span class="keyword">int</span> argc, <span class="keyword">char_t</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char_t</span>	*name, *address;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (ejArgs(argc, argv, T(<span class="string">"%s %s"</span>), &amp;name, &amp;address) &lt; <span class="number">2</span>) &#123;</div><div class="line">		websError(wp, <span class="number">400</span>, T(<span class="string">"Insufficient args\n"</span>));</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> websWrite(wp, T(<span class="string">"Name: %s, Address %s"</span>), name, address);</div><div class="line">&#125;</div><div class="line">websAspDefine(T(<span class="string">"aspTest"</span>), aspTest);</div></pre></td></tr></table></figure>
<h3 id="GoForm过程"><a href="#GoForm过程" class="headerlink" title="GoForm过程"></a>GoForm过程</h3><h4 id="根据Form表单Post上来的表单信息去设置和管理嵌入式系统设备"><a href="#根据Form表单Post上来的表单信息去设置和管理嵌入式系统设备" class="headerlink" title="根据Form表单Post上来的表单信息去设置和管理嵌入式系统设备"></a>根据Form表单Post上来的表单信息去设置和管理嵌入式系统设备</h4><ul>
<li>GoAhead WebServer可以实现一个灵活的URL处理程序；</li>
<li>.asp网页文件中form表单样式’ action=”/goform/ConfigInfo” action=”post” ‘,goahead服务器url处理器会自动解析goform/之后的内容；</li>
<li>解析后的内容 ConfigInfo 对应于goahead服务器中经过 websFormDefine 注册的C程序，这里与ASP过程中的注册过程类似，这里的C程序负责处理表单数据并与系统主进程通信；</li>
<li>上述的过程便是goahead提供的Goform过程，即内存中的CGI处理过程，与标准的CGI处理过程的区别是这里的Goform过程与goahead服务器进程共享地址空间，Goform过程所需得到的表单信息均由goahead服务器提供的标准的API函数 websGetVar 来获得，标准版本的CGI处理会导致在对于每一个CGIURL的请求产生一个新的进程；<h4 id="具体实例-1"><a href="#具体实例-1" class="headerlink" title="具体实例"></a>具体实例</h4></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">formTest</span><span class="params">(<span class="keyword">webs_t</span> wp, <span class="keyword">char_t</span> *path, <span class="keyword">char_t</span> *query)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char_t</span>	*name, *address;</div><div class="line"></div><div class="line">	name = websGetVar(wp, T(<span class="string">"name"</span>), T(<span class="string">"Joe Smith"</span>)); </div><div class="line">	address = websGetVar(wp, T(<span class="string">"address"</span>), T(<span class="string">"1212 Milky Way Ave."</span>)); </div><div class="line"></div><div class="line">	websHeader(wp);</div><div class="line">	websWrite(wp, T(<span class="string">"&lt;body&gt;&lt;h2&gt;Name: %s, Address: %s&lt;/h2&gt;\n"</span>), name, address);</div><div class="line">	websFooter(wp);</div><div class="line">	websDone(wp, <span class="number">200</span>);</div><div class="line">&#125;</div><div class="line">websFormDefine(T(<span class="string">"formTest"</span>), formTest);</div></pre></td></tr></table></figure>
<hr>
<h2 id="Goahead架构"><a href="#Goahead架构" class="headerlink" title="Goahead架构"></a>Goahead架构</h2><p>   <a href="http://embedthis.com/goahead/" target="_blank" rel="external">GoAhead源码分析—转载</a><br><br>    webs-2-5/</p>
<pre><code>| 各种OS移植子目录，分别有：CE、ECOS、LINUX、LYNX、MACOSX、NW、QNX4、VXWORKS、WIN

| utils：当前只有webcomp.c，即网页编译器 

| www：存放web网页

| wwwdemo：goAhead带的demo网页，里面包含了goAhead的一些文档

| goAhead: 服务器源程序文件(C程序文件)
</code></pre><h2 id="Goahead移植"><a href="#Goahead移植" class="headerlink" title="Goahead移植"></a>Goahead移植</h2><p>本文中的移植过程是转载自下面这篇文献的，虽然目标平台不同，但方法基本一样,致谢原作者！<br><br><a href="http://blog.csdn.net/reille/article/details/6784809" target="_blank" rel="external">Goahead 嵌入式web服务器移植到arm9 2440 + linux中</a></p>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ul>
<li>宿主机<ul>
<li>戴尔windows 10操作系统；</li>
</ul>
</li>
<li>虚拟机<ul>
<li>Redhat Enterprise Linux5；</li>
</ul>
</li>
<li>开发板<ul>
<li>主控芯片为PowerPC架构的MPC85xx系列的实验板；</li>
<li>内核版本linux-2.6.20</li>
</ul>
</li>
<li>交叉编译器<ul>
<li>ppc_8xx-gcc;</li>
</ul>
</li>
</ul>
<h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p>   <a href="http://download.csdn.net/detail/hot_passion/2786665" target="_blank" rel="external">Goahead-2.5 下载链接</a></p>
<h3 id="移植步骤"><a href="#移植步骤" class="headerlink" title="移植步骤"></a>移植步骤</h3><h4 id="修改Makefile文件"><a href="#修改Makefile文件" class="headerlink" title="修改Makefile文件"></a>修改Makefile文件</h4><p>选择LINUX目录下的Makefile文件，添加如下内容:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">AS      = <span class="variable">$(CROSS_COMPILE)</span>as  </div><div class="line">LD      = <span class="variable">$(CROSS_COMPILE)</span>ld  </div><div class="line">CC      = <span class="variable">$(CROSS_COMPILE)</span>gcc   </div><div class="line">AR      = <span class="variable">$(CROSS_COMPILE)</span>ar  </div><div class="line">NM      = <span class="variable">$(CROSS_COMPILE)</span>nm  </div><div class="line">STRIP   = <span class="variable">$(CROSS_COMPILE)</span>strip  </div><div class="line">OBJCOPY = <span class="variable">$(CROSS_COMPILE)</span>objcopy  </div><div class="line">OBJDUMP = <span class="variable">$(CROSS_COMPILE)</span>objdump</div></pre></td></tr></table></figure></p>
<pre><code>这里的CROSS_COMPILE是虚拟机交叉编译环境经变量 ppc_8xx-gcc&lt;br&gt;
同时需要根据情况注释掉Makefile中的下列语句：
</code></pre><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">matrixsslDir:=<span class="variable">$(<span class="built_in">shell</span> ls -d ../matrixssl-3-1*/)</span></div></pre></td></tr></table></figure>
<p>这一句是用来启动SSL matrixssl的,若当前系统不支持，就按上面所说注释掉这一句；Goahead官方文档中给出的说明如下：<br></p>
<ul>
<li>The Makefiles for LINUX and MACOSX will detect the MatrixSSL package, apply the necessary preprocessor defines, and link with the SSL library.</li>
</ul>
<h4 id="修改main-c文件"><a href="#修改main-c文件" class="headerlink" title="修改main.c文件"></a>修改main.c文件</h4><p>由于LINUX/main.c文件：initWebs()函数中原程序无法正确获得服务器IP；因此置服务器一个静态IP地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> *  Define the local Ip address, host name, default home page and the </div><div class="line"> *  root web directory. </div><div class="line"> */  </div><div class="line"> <span class="comment">/* del by gyr 2011.09.17 </span></div><div class="line">	if (gethostname(host, sizeof(host)) &lt; 0) &#123; </div><div class="line">		error(E_L, E_LOG, T("Can't get hostname")); </div><div class="line">		printf("initWebs::Can't get hostname.\n");     </div><div class="line">		return -1; </div><div class="line">	&#125; </div><div class="line">	if ((hp = gethostbyname(host)) == NULL) &#123; </div><div class="line">		error(E_L, E_LOG, T("Can't get host address")); </div><div class="line">		printf("initWebs::Can't get hostname...\n");    </div><div class="line">		return -1; </div><div class="line">	&#125; </div><div class="line">	memcpy((char *) &amp;intaddr, (char *) hp-&gt;h_addr_list[0], </div><div class="line">		(size_t) hp-&gt;h_length); </div><div class="line">*/  </div><div class="line">	intaddr.s_addr = inet_addr(T(<span class="string">"192.168.186.138"</span>));</div></pre></td></tr></table></figure></p>
<p>此处的ip地址可以是我们指定好的实验板的ip地址，也可以是在这里编写程序使得goahead服务器到flash中读取得到的地址；<br></p>
<h4 id="修改default-c文件"><a href="#修改default-c文件" class="headerlink" title="修改default.c文件"></a>修改default.c文件</h4><p>在上文中提到的本次移植过程的参考文章中碰到了打不开网页的现象，我在实践过程中也遇到了相同的情况；错误提示：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Access Error: Site or Page Not Found</div><div class="line"></div><div class="line">Cannot open URL</div></pre></td></tr></table></figure></p>
<p>参考文章给出了解决方法，这里就不详细描述了，解决方法请参考上文链接；这个错误与默认网页的处理有关，具体涉及到了default.c文件中的WebsDefaultHandler()函数。</p>
<h4 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h4><pre><code>修改完必要的文件之后便可以执行编译过程了
</code></pre><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make clean; make</div></pre></td></tr></table></figure>
<p>编译成功之后会生成一个可执行的文件./webs和一个./libwebs.a的静态库文件，由于我这里实验板使用的文件系统为网络文件系统NFS，所以这里可以复制这两个文件所在目录与网页文件所在目录到目标版的文件系统当中，执行程序<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./webs</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./webs -demo</div></pre></td></tr></table></figure></p>
<p>之后打开浏览器，访问<a href="http://192.168.186.138:8080" target="_blank" rel="external">http://192.168.186.138:8080</a> 便可以访问到默认网页内容。<br><br><img src="/img/goahead默认网页.png" alt="Goahead默认网页"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>接下来的过程中我将使用Goahead作为web服务器完成路由器网络管理部分应用层的设计，主要是面向管理人员和用户的网页管理配置部分的内容。</p>
]]></content>
      
        <categories>
            
            <category> web服务器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> web </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[嵌入式开发Linux服务器搭建]]></title>
      <url>/2017/05/23/Linux_server/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    学习嵌入式开发，首先在电脑上安装了VMWare虚拟机，虚拟机中安装redhat服务器版操作系统。接下来便是建立基本的开发环境，Let‘s Go！</p>
<h3 id="Samba服务器安装"><a href="#Samba服务器安装" class="headerlink" title="Samba服务器安装"></a>Samba服务器安装</h3><p>​    随着Linux的普及，如何共享Linux下的文件成为用户关心的问题。SMB（Server Message Block，服务信息块）是局域网上的共享文件夹/打印机的一种协议，Linux使用一个被称为Samba的程序来实现SMB协议。其实，几乎所有的Linux发行套件都提供了一个很好的工具Samba——通过它可以轻松实现文件共享。</p>
<h4 id="下载安装samba"><a href="#下载安装samba" class="headerlink" title="下载安装samba"></a>下载安装samba</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> yum -y install samba</div></pre></td></tr></table></figure>
<p>此命令会联网搜索安装包（前提是虚拟机linux中的ip与DNS正确配置），若网络配置正确仍然不能搜索安装包，则需要更新yum源：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /etc/yum.repos.d/  进入yum配置目录</div><div class="line">wget http://docs.linuxtone.org/soft/lemp/CentOS-Base.repo 下载相关文件</div><div class="line">mv CentOS-Base.repo rhel-debuginfo.repo 这一步之前做好备份</div><div class="line">yum install build-essential 安装</div></pre></td></tr></table></figure>
<p>之后再运行安装samba的命令便可以安装成功samba</p>
<h4 id="查看samba是否安装"><a href="#查看samba是否安装" class="headerlink" title="查看samba是否安装"></a>查看samba是否安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -q samba</div></pre></td></tr></table></figure>
<h4 id="服务配置文件"><a href="#服务配置文件" class="headerlink" title="服务配置文件"></a>服务配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#vi /etc/samba/smb.conf</div><div class="line">[zhanghao]</div><div class="line">        path = /home/zhanghao</div><div class="line">        writeable = yes</div><div class="line">        browseable = yes</div><div class="line">        valid users = zhanghao</div><div class="line">[embed-Ocean.Ho]</div><div class="line">        path = /embed-Ocean.Ho</div><div class="line">        public = yes</div><div class="line">        writable = yes</div><div class="line">        printable = no</div><div class="line">        write list = 500</div><div class="line">        directory mask = 0777</div><div class="line">        create mask = 0777</div><div class="line">[usr-include]</div><div class="line">        path=/usr/include</div><div class="line">        writeable = no</div><div class="line">        browseable = yes</div><div class="line">        valid users = zhanghao</div><div class="line">        directory mask = 0777</div><div class="line">        public = yes</div><div class="line">        printable = no</div></pre></td></tr></table></figure>
<h4 id="Samba用户建立"><a href="#Samba用户建立" class="headerlink" title="Samba用户建立"></a>Samba用户建立</h4><p>Samba是默认在user模式下的，需要用户名和密码来查看共享文档。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">smbpasswd -a 用户名 #添加samba用户</div><div class="line">smbpasswd -e 用户名 #激活用户</div></pre></td></tr></table></figure>
<p>（-a 创建 -e 启用 -d 禁用 -x 删除）</p>
<h4 id="启动Samba服务"><a href="#启动Samba服务" class="headerlink" title="启动Samba服务"></a>启动Samba服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/etc/rc.d/init.d/smb start  #（可以使用ntsysv设置开机自启动）</div><div class="line">/etc/rc.d/init.d/smb stop	   #停止	</div><div class="line">/etc/rc.d/init.d/smb restart  #（修改过配置文件需要重启）</div></pre></td></tr></table></figure>
<h4 id="Windows端查看共享目录"><a href="#Windows端查看共享目录" class="headerlink" title="Windows端查看共享目录"></a>Windows端查看共享目录</h4><p>在映射网络驱动器登陆中如下图红框（\192.168.186.138\zhanghao）：</p>
<p><img src="/img/windows_samba.png" alt="shared_folder"></p>
<h3 id="NFS服务器"><a href="#NFS服务器" class="headerlink" title="NFS服务器"></a>NFS服务器</h3><p>为了方便调试，需要在linux下设置nfs服务器，实现硬件设备boot启动使用NFS网络文件系统。配置方法如下（此部分需要root权限）<br><img src="/img/nfs_demo.png" alt="shared_folder"></p>
<h4 id="nfs所需的软件包"><a href="#nfs所需的软件包" class="headerlink" title="nfs所需的软件包"></a>nfs所需的软件包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -q nfs-utils portmap</div><div class="line">nfs-utils-1.0.6-70.EL4</div><div class="line">portmap-4.0-63</div></pre></td></tr></table></figure>
<h4 id="NFS服务器的配置文件"><a href="#NFS服务器的配置文件" class="headerlink" title="NFS服务器的配置文件"></a>NFS服务器的配置文件</h4><p>/etc/exports文件下进行配置，默认为空</p>
<p>参考示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/home/zhanghao/task/tc408el/initrd-nfs/ *(rw,no_root_squash,async)</div><div class="line">/home/zhuj/tc480ec/initrd-nfs/ *(rw,no_root_squash,async)</div><div class="line">/home/liuxk/tc480ec/initrd-nfs/ *(rw,no_root_squash,async)</div><div class="line">/home/wangjb/tc480ec/initrd-nfs/ *(rw,no_root_squash,async)</div></pre></td></tr></table></figure>
<h3 id="交叉编译工具（PowerPC系列）"><a href="#交叉编译工具（PowerPC系列）" class="headerlink" title="交叉编译工具（PowerPC系列）"></a>交叉编译工具（PowerPC系列）</h3><p>为了能够编译出硬件设备能够识别的二进制代码，需要安装交叉编译环境。ELDK是Embeded Linux Development Kit的缩写，是德国denx提供的供PowerPC嵌入式Linux移植的完整开发环境编译套件。</p>
<h4 id="下载ISO镜像文件"><a href="#下载ISO镜像文件" class="headerlink" title="下载ISO镜像文件"></a>下载ISO镜像文件</h4><p>Denx为PPC（PowerPC）系列的CPU提供了多种ISO镜像文件。从ELDK的使用说明（ISO中的README.html）中能看到：</p>
<p>​                        <strong>one for the 8xx, 6xx, 74xx and 85xx families (Freescale)</strong></p>
<p>下载：<a href="http://ftp.denx.de/pub/eldk/4.2/ppc-linux-x86/iso/ppc-2008-04-01_freescale.iso" target="_blank" rel="external">http://ftp.denx.de/pub/eldk/4.2/ppc-linux-x86/iso/ppc-2008-04-01_freescale.iso</a></p>
<p>下载完成后在linux中mount命令挂载iso文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -o loop /home/zhanghao/task/tc408el/rhel-server-6.3-x86_64-dvd.iso  /home/zhanghao/mnt/cdrom</div></pre></td></tr></table></figure>
<p>挂载成功后便可以在mnt目录下看到相关文件。</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./install –d /home/zhanghao/edlk  ppc_8xx</div></pre></td></tr></table></figure>
<p>之后便可以在edlk目录下看到相关文件：</p>
<p><img src="/img/eldk_init.png" alt="shared_folder"> </p>
<h4 id="声明环境变量"><a href="#声明环境变量" class="headerlink" title="声明环境变量"></a>声明环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export LANG=C</div><div class="line">export CROSS_COMPILE=ppc_8xx-</div><div class="line">export ARCH=ppc</div><div class="line">export PATH=$PATH:/home/zhanghao/eldk/usr/bin/</div></pre></td></tr></table></figure>
<p>保存后使用命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source .bashrc</div></pre></td></tr></table></figure>
<p>至此PowerPc平台交叉编译环境已经建立完毕</p>
<h4 id="Helloworld实验"><a href="#Helloworld实验" class="headerlink" title="Helloworld实验"></a>Helloworld实验</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ppc_8xx-gcc helloworld.c  -o helloworld  #编译成功</div></pre></td></tr></table></figure>
<p><img src="/img/helloworld.png" alt="shared_folder"></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> server </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/05/22/hello-world/</url>
      <content type="html"><![CDATA[<pre><code>欢迎来到我的博客
文章以嵌入式系统相关内容为主，其中有错误的地方欢迎及时指正，共勉！
</code></pre>]]></content>
      
        
    </entry>
    
  
  
</search>
