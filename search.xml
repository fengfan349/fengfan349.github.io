<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GPIO驱动学习实践]]></title>
    <url>%2F2017%2F06%2F02%2Fgpio_driver%2F</url>
    <content type="text"><![CDATA[简介linux驱动有三大类：字符设备驱动、块设备驱动、网络设备驱动 本文关注的是字符设备驱动-----以LED驱动为例 程序设计头文件下面是一些必要的头文件：1234567891011121314151617181920212223#include &lt;linux/module.h&gt;#include &lt;linux/moduleparam.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/kernel.h&gt; /* printk() */#include &lt;linux/slab.h&gt; /* kmalloc() */#include &lt;linux/fs.h&gt; /* everything... */#include &lt;linux/errno.h&gt; /* error codes */#include &lt;linux/types.h&gt; /* size_t */#include &lt;linux/proc_fs.h&gt;#include &lt;linux/fcntl.h&gt; /* O_ACCMODE */#include &lt;linux/aio.h&gt;#include &lt;linux/ioport.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/ioctl.h&gt; /* needed for the _IOW etc stuff used later */#include &lt;linux/mm.h&gt;#include &lt;linux/delay.h&gt;#include &lt;linux/cdev.h&gt;#include &lt;linux/device.h&gt;#include &lt;asm/uaccess.h&gt; /*put_user*/#include &lt;asm/io.h&gt;#include &lt;asm/system.h&gt; /* cli(), *_flags */#include &lt;asm/page.h&gt;#include &lt;asm/semaphore.h&gt; 宏定义IMMAP内部存储器映射寄存器这一部分是IO空间对应的唯一的物理空间地址：12345678910111213141516171819#define IMMAP_BASE 0xFF000000 //物理地址#define IMMAP_LEN 0x100000 //地址空间大小/* 此处一般有一个自定义设备结构体，用来保存设备相关的各种信息，包括主、次设备号，物理地址映射寄存器等必要结构，如下所示 */typedef struct io_dev_s&#123; u16 major; u16 minor; gpio_pa pa; gpio_pb pb; gpio_pd pd; gpio_pc pc; u32 phy_immr; u32 phy_base; u32 phy_len; struct class *cs; struct class_device *cd; spinlock_t lock; struct cdev cdev;&#125;io_dev; 用户程序在运行中不能直接访问物理地址,这个地址是唯一的，我们需要将物理地址映射到0~4G大小的虚拟地址空间供用户程序使用；而驱动程序可以分为用户模式驱动和内核模式驱动： 地址空间划分 linux内核将虚拟地址空间划分为两部分供用户使用 用户空间：0x00000000~0xBFFFFFFF的3G大小的低地址空间； 内核空间：0xC0000000~0xFFFFFFFF的1G大小的高地址空间。 设备驱动模式 用户驱动模式： 实现函数： 1immr_map (&amp;immr, IMMAP_LEN, IMMAP_BASE); //将物理地址空间映射到低3G地址的用户空间，将映射后的地址保存在immr内部存储器映射寄存器中 上述函数实现物理地址映射是通过系统调用mmap函数实现的，过程如下： 12fd = open (MEM_FILE, O_RDWR)) //打开内存文件 /dev/mem*start = (VUINT32) mmap (NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FILE, fd, base)) //返回映射到用户进程虚拟地址空间的基地址 注：mmap负责把文件内容映射到进程的虚拟地址空间，通过对这段内存的读取和修改来实现对文件的读取和修改，而不需要再调用read和write；这里的操作是把系统内存看作一个文件，而GPIO相关的寄存器是这个文件中的一部分内容，通过映射,GPIO的实际物理地址映射为用户空间的虚拟地址，这样返回一个虚拟空间GPIO的起始地址，便可以根据地址偏移量计算每个寄存器的虚拟地址，进而达到在用户空间程序直接访问的目的。 内核驱动模式： 实现函数： 12request_mem_region(io_dev.phy_base, io_dev.phy_len, IO_DRIVER_NAME); //为该驱动向内核申请指定物理地址的使用权，一旦获得使用权其他驱动便不可以使用这段内存；(unsigned long) ioremap(io_dev.phy_base, io_dev.phy_len)； //得到该段物理地址空间的权限之后还需要将该段物理地址映射到内核地址空间，供内核调用； 这里内核驱动模式与用户驱动模式的区别在于用户模式下驱动的控制是直接读写IO的映射之后的虚拟地址实现的，而本部分的内核调用是先使用系统调用函数诸如read，write等等进入内核空间，再由内核使用内核调用函数（由用户编写的read，write，ioctl等函数，下面会提到）来实现对IO的控制；本次对于GPIO驱动的控制是使用的内核驱动模式。 主、次设备号12#define IO_MAJOR 211 #define IO_MINOR 0 在Linux内核看来，主设备号标识设备对应的驱动程序，告诉Linux内核使用哪一个驱动程序为该设备(也就是/dev下的设备文件)服务；而次设备号则用来标识具体且唯一的某个设备。 驱动实现 io_init &amp; io_exit 实现物理地址到内核空间的映射并计算各个寄存器的地址偏移量； 获取dev_t类型的设备编号并以此向内核注册该设备： 12dev = MKDEV(io_dev.major,io_dev.minor);register_chrdev_region(dev, 1, IO_DRIVER_NAME); 编写各个内核调用的函数诸如：io_open, io_close, io_read, io_write,io_ioctl,同时初始化file_operations结构体，实例如下： 1234567891011121314151617181920212223242526272829303132/*这里以io_ioctl为例*/ssize_t io_ioctl(struct inode * inode, struct file *filp, unsigned int cmd, unsigned long arg)&#123; io_dev * dev; //自定义设备结构体 dev = filp-&gt;private_data; switch(cmd) &#123; case LED_CTRL_INIT: *(dev-&gt;pb.pbpar) &amp;= ~(arg); *(dev-&gt;pb.pbdir) |= arg; break; case LED_CTRL_ON: *(dev-&gt;pb.pbdat) &amp;= ~(arg); break; case LED_CTRL_OFF: *(dev-&gt;pb.pbdat) |= arg; break; default: return -1; break; &#125; return 0;&#125;struct file_operations io_fops = &#123; .owner = THIS_MODULE, .read = io_read, .write = io_write, .open = io_open, .ioctl = io_ioctl, .release = io_release, &#125;; 初始化cdev结构体，cdev结构体是设备驱动实现的关键，cdev是linux用来管理字符设备的结构体，其在内核中采用数组结构设计，这样系统中有多少个主设备号就约定了数组大小，此设备号采用链表管理，同一主设备号下可以有多个子设备。设备即文件，上层应用要访问设备，必须通过文件，cdev中包含file_operations结构体，该结构体就是驱动的文件操作集合。其分为一下几个步骤： 12345cdev_init(&amp;dev-&gt;cdev, &amp;io_fops);dev-&gt;cdev.owner = THIS_MODULE;dev-&gt;cdev.ops = &amp;io_fops;cdev_add (&amp;dev-&gt;cdev, devno, 1); 创建设备类，使得当调用insmod命令加载驱动时可以自动在/dev目录下创建该设备节点文件 12io_dev.cs = class_create(THIS_MODULE,IO_DRIVER_NAME);io_dev.cd = class_device_create(io_dev.cs, NULL, dev, NULL, IO_DRIVER_NAME); 卸载设备-io_exit 前面部分实现的是设备加载时调用执行的程序即io_init(),而设备退出时也需要响应的函数即io_exit: 1234cdev_del(&amp;io_dev.cdev);unregister_chrdev_region(MKDEV (io_dev.major, io_dev.minor), 1);iounmap((void __iomem *)io_dev.phy_immr);release_mem_region(io_dev.phy_base,io_dev.phy_len); 至此设备驱动基本编写完毕，但仍有一些后续工作：123456module_init(io_init); /* load the module */module_exit(io_exit); /* unload the module *//* before is some decription of the model,not necessary */MODULE_LICENSE("Dual BSD/GPL");MODULE_AUTHOR("zhangh"); 编译驱动这里需要将源文件编译为.ko的驱动模块，使用insmod加载到内核，相应的rmmod命令删除驱动模块。 下面是一个标准的Makefile： 12345678910111213141516171819ifeq ($(KERNELRELEASE),) #开始满足这个条件 KERNELRELEASE为空 KERNELDIR ?= /home/zhanghao/task/kernal/linux-2.6.20 #指定Linux内核目录位置 PWD := $(shell pwd) #打印当前驱动源码的本地位置 modules: #编译为驱动模块 $(MAKE) -C $(KERNELDIR) M=$(PWD) modules #-C 指定内核Makefile的路径，可以使用相对路径。 #-M 指定要编译的文件的路径，可以使用相对路径。 modules: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions modules.order Module.symvers else #再次读取这个Makefile文件时 KERNELRELEASE已被赋值MODULE_NAME := my_gpio #指定驱动模块的名字 ,不要和当前目录下的文件同名(算上扩展名比较) CORE_OBJS := my_gpio.o #指定驱动模块的核心文件（有init 和 exit） DEPE_OBJS := *.o #除了核心文件以外的其它依赖文件 $(MODULE_NAME)-objs := $(DEPE_OBJS) $(CORE_OBJS) #指定驱动模块的所有依赖文件 obj-m := my_gpio.o #最终由xxx-objs链接生成my_gpio.o，再生成my_gpio.ko endif Makefile参考链接]]></content>
      <categories>
        <category>嵌入式linux驱动</category>
      </categories>
      <tags>
        <tag>GPIO</tag>
        <tag>字符设备驱动</tag>
        <tag>LED</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoAhead WebServer学习]]></title>
    <url>%2F2017%2F05%2F27%2F2017-05-27%2F</url>
    <content type="text"><![CDATA[Goahead简介GoAhead WebServer 它是一个源码免费、功能强大、可以在多个平台运行的嵌入式WebServer。 支持ASP 嵌入式的javascript 标准的CGI执行 内存中的CGI处理GoForms 扩展的API 快速响应，每秒可处理超过50个请求 完全和标准兼容 如果不包含SSI，仅要求60K的内存；包含SSI，要求500K内存 web页面可以存在ROM或文件系统中 支持多种操作系统，包括eCos 、LINUX 、LynxOS 、QNX 、VxWorks 、WinCE Goahead核心ASP过程用来获得嵌入式系统正在运行中的进程的各种状态信息，并最终返回响应浏览 在goahead服务器中，网页以.asp的扩展名保存，asp是一种动态服务页面； 要创建一个ASP文件中的ASP脚本就必须使用asp界定符 &lt;% function(arguments, …); %&gt;，这里的脚本使用goahead所支持的嵌入式javascript即Ejscript； Ejscript由goahead提供支持，goahead提供Ejscript解析器负责解析脚本函数，定位、传递脚本函数中的实参给此脚本函数对应的c语言实现的经过注册的全局函数; 在goahead源码中使用一个自己定义的c函数，这个c函数通过调用goahead服务器中API函数 websAspDefine 向服务器注册此c函数，这样此c函数便成为了Ejscript的一个全局函数，负责具体实现Ejscript查询显示信息的功能。具体实例 1234567891011static int aspTest(int eid, webs_t wp, int argc, char_t **argv)&#123; char_t *name, *address; if (ejArgs(argc, argv, T("%s %s"), &amp;name, &amp;address) &lt; 2) &#123; websError(wp, 400, T("Insufficient args\n")); return -1; &#125; return websWrite(wp, T("Name: %s, Address %s"), name, address);&#125;websAspDefine(T("aspTest"), aspTest); GoForm过程根据Form表单Post上来的表单信息去设置和管理嵌入式系统设备 GoAhead WebServer可以实现一个灵活的URL处理程序； .asp网页文件中form表单样式’ action=”/goform/ConfigInfo” action=”post” ‘,goahead服务器url处理器会自动解析goform/之后的内容； 解析后的内容 ConfigInfo 对应于goahead服务器中经过 websFormDefine 注册的C程序，这里与ASP过程中的注册过程类似，这里的C程序负责处理表单数据并与系统主进程通信； 上述的过程便是goahead提供的Goform过程，即内存中的CGI处理过程，与标准的CGI处理过程的区别是这里的Goform过程与goahead服务器进程共享地址空间，Goform过程所需得到的表单信息均由goahead服务器提供的标准的API函数 websGetVar 来获得，标准版本的CGI处理会导致在对于每一个CGIURL的请求产生一个新的进程；具体实例 12345678910111213static void formTest(webs_t wp, char_t *path, char_t *query)&#123; char_t *name, *address; name = websGetVar(wp, T("name"), T("Joe Smith")); address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); websHeader(wp); websWrite(wp, T("&lt;body&gt;&lt;h2&gt;Name: %s, Address: %s&lt;/h2&gt;\n"), name, address); websFooter(wp); websDone(wp, 200);&#125;websFormDefine(T("formTest"), formTest); Goahead架构 GoAhead源码分析—转载 webs-2-5/ | 各种OS移植子目录，分别有：CE、ECOS、LINUX、LYNX、MACOSX、NW、QNX4、VXWORKS、WIN | utils：当前只有webcomp.c，即网页编译器 | www：存放web网页 | wwwdemo：goAhead带的demo网页，里面包含了goAhead的一些文档 | goAhead: 服务器源程序文件(C程序文件) Goahead移植本文中的移植过程是转载自下面这篇文献的，虽然目标平台不同，但方法基本一样,致谢原作者！Goahead 嵌入式web服务器移植到arm9 2440 + linux中 开发环境 宿主机 戴尔windows 10操作系统； 虚拟机 Redhat Enterprise Linux5； 开发板 主控芯片为PowerPC架构的MPC85xx系列的实验板； 内核版本linux-2.6.20 交叉编译器 ppc_8xx-gcc; 源码下载 Goahead-2.5 下载链接 移植步骤修改Makefile文件选择LINUX目录下的Makefile文件，添加如下内容:12345678AS = $(CROSS_COMPILE)as LD = $(CROSS_COMPILE)ld CC = $(CROSS_COMPILE)gcc AR = $(CROSS_COMPILE)ar NM = $(CROSS_COMPILE)nm STRIP = $(CROSS_COMPILE)strip OBJCOPY = $(CROSS_COMPILE)objcopy OBJDUMP = $(CROSS_COMPILE)objdump 这里的CROSS_COMPILE是虚拟机交叉编译环境经变量 ppc_8xx-gcc&lt;br&gt; 同时需要根据情况注释掉Makefile中的下列语句： 1matrixsslDir:=$(shell ls -d ../matrixssl-3-1*/) 这一句是用来启动SSL matrixssl的,若当前系统不支持，就按上面所说注释掉这一句；Goahead官方文档中给出的说明如下： The Makefiles for LINUX and MACOSX will detect the MatrixSSL package, apply the necessary preprocessor defines, and link with the SSL library. 修改main.c文件由于LINUX/main.c文件：initWebs()函数中原程序无法正确获得服务器IP；因此置服务器一个静态IP地址。12345678910111213141516171819/* * Define the local Ip address, host name, default home page and the * root web directory. */ /* del by gyr 2011.09.17 if (gethostname(host, sizeof(host)) &lt; 0) &#123; error(E_L, E_LOG, T("Can't get hostname")); printf("initWebs::Can't get hostname.\n"); return -1; &#125; if ((hp = gethostbyname(host)) == NULL) &#123; error(E_L, E_LOG, T("Can't get host address")); printf("initWebs::Can't get hostname...\n"); return -1; &#125; memcpy((char *) &amp;intaddr, (char *) hp-&gt;h_addr_list[0], (size_t) hp-&gt;h_length); */ intaddr.s_addr = inet_addr(T("192.168.186.138")); 此处的ip地址可以是我们指定好的实验板的ip地址，也可以是在这里编写程序使得goahead服务器到flash中读取得到的地址； 修改default.c文件在上文中提到的本次移植过程的参考文章中碰到了打不开网页的现象，我在实践过程中也遇到了相同的情况；错误提示：123Access Error: Site or Page Not FoundCannot open URL 参考文章给出了解决方法，这里就不详细描述了，解决方法请参考上文链接；这个错误与默认网页的处理有关，具体涉及到了default.c文件中的WebsDefaultHandler()函数。 编译源码修改完必要的文件之后便可以执行编译过程了 1make clean; make 编译成功之后会生成一个可执行的文件./webs和一个./libwebs.a的静态库文件，由于我这里实验板使用的文件系统为网络文件系统NFS，所以这里可以复制这两个文件所在目录与网页文件所在目录到目标版的文件系统当中，执行程序1./webs 或者1./webs -demo 之后打开浏览器，访问http://192.168.186.138:8080 便可以访问到默认网页内容。 后续接下来的过程中我将使用Goahead作为web服务器完成路由器网络管理部分应用层的设计，主要是面向管理人员和用户的网页管理配置部分的内容。]]></content>
      <categories>
        <category>web服务器</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到我的博客 文章以嵌入式系统相关内容为主，其中有错误的地方欢迎及时指正，共勉！]]></content>
  </entry>
</search>